#!/usr/bin/env python3
#
#+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#                                                                       #
#                                 SWANmat2sel.py                        # 
#                                                                       #
#+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#
# Author: Pat Prodanovic, Ph.D., P.Eng.
# 
# Date: July 4, 2017
#
# Purpose: Script takes in a binary Matlab output file generated by a 
# run from an unstructured SWAN calculation, and outputs the data to a
# a *.slf file format. Script assumes the SWAN directions are in NAUT
# convention, and that these output variables XP YP DEP HS DIR RTP FORCE
# are specified in the *.swn steering file:
#
# BLOCK 'COMPGRID' NOHEAD 'out.mat' LAY 3 XP YP DEP HS DIR RTP FORCE
#
# If there are other variables present, the script simply ignores them
#
# For now, it only works for stationary SWAN simulations.
# TODO: update for non-stationary output as well
#
# Uses: Python 2 or 3, Numpy, Scipy
#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Global Imports
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import os,sys                              # system parameters
import numpy             as np             # numpy
import math
import scipy.io          as io             # scipy's io functions for loadmat()
from ppmodules.readMesh import *           # to get all readMesh functions
from ppmodules.selafin_io_pp import *      # to get all read/write SELAFIN files
from ppmodules.utilities import *          # utilities
#
if len(sys.argv) != 7:
  print('Wrong number of Arguments, stopping now...')
  print('Usage:')
  print('python SWANmat2sel.py -m out.grd -i out.mat -o out.slf')
  sys.exit()

# I/O
adcirc_file = sys.argv[2]        # input *.grd file (adcirc mesh file)
input_file = sys.argv[4]         # input *.mat file (swan output)
output_file = sys.argv[6]        # output *.slf file 

# output *.csv file
fout = open(output_file, "w")

# uses scipy's loadmat function, and produces one master dictionary
mat = io.loadmat(input_file)

# remove from the dictionary __header__, __version__, __globals__
# it assumes all of these dictionary keys already exist 
mat.pop('__header__', None)
mat.pop('__version__', None)
mat.pop('__globals__', None)
mat.pop('Yp', None)
mat.pop('Xp', None)

# get the dict keys (i.e., var names)
v = list(mat.keys())

# initialize the variables as arrays filled with zeros
Depth = mat['Depth'][0,:] # Depth must be present
num_pts = len(Depth)

Hsig = np.zeros(num_pts)
RTpeak = np.zeros(num_pts)
Dir = np.zeros(num_pts)
WForce_x = np.zeros(num_pts)
WForce_y = np.zeros(num_pts)

for i in range (len(v)):
  # find the variables in the mat dictionary
  if (v[i].find('Hsig') > -1):
    Hsig = mat['Hsig'][0,:]
  elif(v[i].find('RTpeak') > -1):
    RTpeak = mat['RTpeak'][0,:]
  elif(v[i].find('Dir') > -1):
    Dir = mat['Dir'][0,:]
  elif(v[i].find('Depth') > -1):
    Depth = mat['Depth'][0,:]
  elif(v[i].find('WForce_x') > -1):
    WForce_x = mat['WForce_x'][0,:]
  elif(v[i].find('WForce_y') > -1):
    WForce_y = mat['WForce_y'][0,:]
    
# in case the fort.14 file in SWAN calculations has a -ve depth (i.e., an
# elevation value above Chart Datum, SWAN assigns a nan to this node)
for i in range(num_pts):
  if (Depth[i] < 0.0):
    Hsig[i] = 0.0
    RTpeak[i] = 0.0
    Dir[i] = 0.0
    WForce_x[i] = 0.0
    WForce_y[i] = 0.0

# now take the adcirc file, and produce a *.slf file out of it

# reads the ADCIRC mesh file first
#n,e,x,y,z,ikle = readAdcirc(adcirc_file)

# use getIPOBO_IKLE() to get IPOBO and IKLE arrays
# this method also writes a 'temp.cli' file as well
n,e,x,y,z,IKLE,IPOBO = getIPOBO_IKLE(adcirc_file)

# rename temp.cli to proper name
cli_file = output_file.split('.',1)[0] + '.cli'
os.rename('temp.cli',cli_file)

# make it a double precision *.slf file
ftype = 'd'
fsize = 8

# to accomodate code pasting
NELEM = e
NPOIN = n
NDP = 3

# now we are ready to write the output *.slf file
out = ppSELAFIN(output_file)
out.setPrecision(ftype, fsize) 
out.setTitle('created with pputils')
out.setVarNames(['BOTTOM          ','WAVE HEIGHT HM0 ','MEAN DIRECTION  ',
  'PEAK PERIOD TPD ','FORCE FX        ','FORCE FY        ' ])
out.setVarUnits(['M               ','M               ','DEG             ',
  'S               ','M/S2            ','M/S2            '])
out.setIPARAM([1, 0, 0, 0, 0, 0, 0, 0, 0, 1])
out.setMesh(NELEM, NPOIN, NDP, IKLE, IPOBO, x, y)
out.writeHeader()

# there is only 1 time step in the file (because the swan simulation
# is stationary

# must convert swan dir to tomawac's nautical convention before writing to
# SELAFIN file (this will make it consistent with my sel2vtk.py script)

# dir = azimuth, arrow pointing towards origin, zero is wave from the north
# tom_dir = tomawac's nautical wave convention, arrow starts at the origin,
# zero is wave from the south

# convert swan's Dir to tom_dir
tom_Dir = np.zeros(NPOIN)

for i in range(NPOIN):
  if (Dir[i] < 180.0):
    tom_Dir[i] = Dir[i] + 180.0
  else:
    tom_Dir[i] = Dir[i] - 180.0

# convert swan's WForce_x and WForce_y to tomawac's FORCE_FX and FORCE_FY variables
FORCE_FX = np.zeros(NPOIN)
FORCE_FY = np.zeros(NPOIN)

for i in range(NPOIN):
  # to prevent division by zero error
  if (abs(Depth[i]) < 0.05):
    Depth[i] = 0.05
      
  FORCE_FX[i] = (WForce_x[i] / (1025.0 * Depth[i]))
  FORCE_FY[i] = (WForce_y[i] / (1025.0 * Depth[i]))

# there are 6 variables to write to the *.slf file  
res = np.zeros((6,NPOIN))

res[0,:] = Depth
res[1,:] = Hsig
res[2,:] = tom_Dir
res[3,:] = RTpeak
res[4,:] = FORCE_FX
res[5,:] = FORCE_FY

out.writeVariables(0.0,res)
