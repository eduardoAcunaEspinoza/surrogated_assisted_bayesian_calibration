#!/usr/bin/env python3
#
#+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#                                                                       #
#                                 SWANmat2csv.py                        # 
#                                                                       #
#+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!+!
#
# Author: Pat Prodanovic, Ph.D., P.Eng.
# 
# Date: December 2, 2015
# 
# Modified: Feb 21, 2016
# Made it work for python 2 or 3
#
# Purpose: Script takes in a binary Matlab output file generated by a 
# run from an unstructured SWAN calculation, and outputs the data to a
# text file. Assume the SWAN output has ouput vars XP YP DEP HS DIR RTP
# which is achieved by having the following line in the *.swn file:
#
# BLOCK 'COMPGRID' NOHEAD 'out.mat' LAY 3 XP YP DEP HS DIR RTP 
#
# It assumes that the *.swn steering file is generated using the nautical
# direction convention (where the wind is coming from).
#
# For now, it only works for stationary SWAN simulations.
# TODO: update for non-stationary output as well
#
# Uses: Python 2 or 3, Numpy, Scipy
#
# Example:
#
# python SWANmat2csv.py -i out.mat -o out.csv
# where:
# -i output *.mat file generated by unstructured swan
# -o output *.csv file 
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Global Imports
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
import os,sys                              # system parameters
import numpy             as np             # numpy
import scipy.io          as io             # scipy's io functions for loadmat()
# 
if len(sys.argv) != 5:
	print('Wrong number of Arguments, stopping now...')
	print('Usage:')
	print('python SWANmat2csv.py -i out.mat -o out.txt')
	sys.exit()

# I/O
input_file = sys.argv[2]         # input *.mat file
output_file = sys.argv[4]        # output *.csv file

# output *.csv file
fout = open(output_file, "w")

# uses scipy's loadmat function, and produces one master dictionary
mat = io.loadmat(input_file)

# load variable names from the *.mat file
v = list(mat.keys())

# v names are these strings
#['Hsig', 'RTpeak', 'Depth', 'Yp', 'Xp', 'Dir']

for i in range (len(v)):
	# find the variables in the mat dictionary
	if (v[i].find('Hsig') > -1):
		Hsig = mat['Hsig']
	elif(v[i].find('RTpeak') > -1):
		RTpeak = mat['RTpeak']
	elif(v[i].find('Dir') > -1):
		Dir = mat['Dir']
	elif(v[i].find('Xp') > -1):
		Xp = mat['Xp']
	elif(v[i].find('Yp') > -1):
		Yp = mat['Yp']
	elif(v[i].find('Depth') > -1):
		Depth = mat['Depth']
		
# the number of nodes in the file
num_pts = Hsig.shape[1]

# if the Depth in unstructured SWAN is negative, all output variables
# are reported as nan
index = list()
for i in range(num_pts):
	if (Depth[0,i] < 0.0):
		Hsig[0,i] = 0.0
		RTpeak[0,i] = 0.0
		Dir[0,i] = 0.0

# writes the SWAN output as a *.csv file

# write the header (var names in first line, units in second)
fout.write('Xp,Yp,Hsig,RTpeak,Dir,Depth' + '\n')
# fout.write('m,m,m,sec,deg,m' + '\n')

for i in range(num_pts):
	fout.write(str(Xp[0,i]) + ',' + str(Yp[0,i]) + ','+ str(Hsig[0,i]) + ',' +
		str(RTpeak[0,i]) + ','+ str(Dir[0,i]) + ','+ str(Depth[0,i]) + '\n')

